---
title: "WebSocket入門 - リアルタイム通信の基礎"
chapter: 1
description: "WebSocketとは何か、なぜ必要なのかを学び、最初のWebSocket接続を体験します"
estimatedTime: "1-2時間"
exercises: 3
difficulty: "beginner"
tags: ["WebSocket", "基礎", "リアルタイム通信", "HTTP"]
objectives:
  - "WebSocketの基本概念を説明できる"
  - "HTTPとWebSocketの違いを理解している" 
  - "ブラウザでWebSocket接続を実行できる"
  - "WebSocketの適用場面を判断できる"
---

<script lang="ts">
  import WebSocketDemo from '$lib/components/WebSocketDemo.svelte';
  import type { ConnectionState } from '$lib/types/websocket';
  
  // ローカル状態
  let demoConnected: boolean = $state(false);
  let connectionState: ConnectionState = $state('disconnected');
  
  // 接続状態の説明を動的生成
  let statusDescription = $derived(() => {
    switch (connectionState) {
      case 'connecting':
        return '現在サーバーへの接続を試行中です...';
      case 'connected':
        return 'サーバーとの接続が確立されています。メッセージの送受信が可能です。';
      case 'error':
        return '接続でエラーが発生しました。再試行してください。';
      default:
        return 'サーバーに接続されていません。';
    }
  });
</script>

## 🔍 WebSocketとは？

**WebSocket**は、クライアント（ブラウザ）とサーバー間で**双方向のリアルタイム通信**を可能にするプロトコルです。

従来のHTTPでは、クライアントからサーバーへのリクエスト → サーバーからクライアントへのレスポンスという一方向の通信でした。しかし、WebSocketでは一度接続が確立されると、クライアントとサーバーが自由にデータを送受信できます。

### HTTPとWebSocketの違い

| 特徴 | HTTP | WebSocket |
|------|------|-----------|
| **通信方向** | 一方向（リクエスト→レスポンス） | 双方向 |
| **接続** | リクエスト毎に開閉 | 永続的な接続 |
| **オーバーヘッド** | 高い（毎回ヘッダー送信） | 低い（最初だけハンドシェイク） |
| **リアルタイム性** | 低い（ポーリングが必要） | 高い（即座に送受信） |
| **ReadyState** | なし | 4つの状態（0-3）で管理 |

### WebSocketの接続状態（ReadyState）

WebSocketは以下の4つの状態を持ちます：

- **`0` (CONNECTING)**: 接続中
- **`1` (OPEN)**: 接続確立、通信可能 
- **`2` (CLOSING)**: 切断処理中
- **`3` (CLOSED)**: 完全に切断済み

## 🚀 実際に体験してみましょう

下のデモでWebSocket接続を試してください：

<WebSocketDemo 
  serverUrl="wss://echo.websocket.org"
  autoConnect={false}
  showLogs={true}
/>

> **解説**: 上記は実際に動作するWebSocketエコーサーバー（`wss://echo.websocket.org`）です。送信したメッセージがそのまま返ってきます。

## 💡 ここで何が起こっているか？

WebSocket接続では以下の流れで通信が行われます：

### 1. 接続確立
```typescript
const ws: WebSocket = new WebSocket('wss://echo.websocket.org');

// 接続状態を確認
console.log(ws.readyState); // 0 (CONNECTING)
```

### 2. イベントハンドラーの設定
```typescript
ws.onopen = (event: Event): void => {
  console.log('接続が確立されました');
  console.log(ws.readyState); // 1 (OPEN)
};

ws.onmessage = (event: MessageEvent<string>): void => {
  console.log('受信:', event.data);
};

ws.onclose = (event: CloseEvent): void => {
  console.log(`接続終了 (code: ${event.code})`);
  console.log(ws.readyState); // 3 (CLOSED)
};

ws.onerror = (event: Event): void => {
  console.error('エラーが発生しました:', event);
};
```

### 3. メッセージ送信
```typescript
// 接続が確立してから送信
if (ws.readyState === WebSocket.OPEN) {
  ws.send('Hello WebSocket!');
}
```

### 4. 型安全な実装例
```typescript
interface WebSocketMessage {
  type: 'message' | 'notification' | 'error';
  content: string;
  timestamp: number;
}

function sendTypedMessage(ws: WebSocket, message: WebSocketMessage): boolean {
  if (ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify(message));
    return true;
  }
  return false;
}
```

## 🎯 WebSocketが活躍する場面

### 主要な11カテゴリー

1. **リアルタイム通信**: チャットアプリ（Discord、Slack）
2. **共同編集**: Google Docs、Figma、VS Code Live Share
3. **通知・アラート**: 在庫更新、システム監視アラート
4. **データ配信**: 株価、為替、スポーツライブスコア
5. **IoT連携**: スマートホーム、センサーデータ
6. **PWA統合**: オフライン対応、プッシュ通知
7. **シミュレーション**: 教育用、マルチプレイヤー
8. **バックエンド連携**: GraphQL Subscriptions、RPC
9. **セキュリティ・監査**: セッション監視、ログ管理
10. **金融・医療**: リアルタイム取引、患者モニタリング
11. **VR/メタバース**: アバター同期、空間共有

### 適さない場面
- **静的コンテンツ配信**: 画像、CSS、JSファイル
- **一方向データ取得**: REST APIで十分な場合
- **低頻度更新**: 数時間に1回程度の更新

## 📝 演習1: 接続状態の理解

以下のコードの`readyState`の値を予測してください：

```typescript
const ws = new WebSocket('wss://echo.websocket.org');
console.log('A:', ws.readyState); // ?

ws.onopen = () => {
  console.log('B:', ws.readyState); // ?
  ws.close();
};

ws.onclose = () => {
  console.log('C:', ws.readyState); // ?
};
```

<details>
<summary>答えを見る</summary>

- **A: 0 (CONNECTING)** - WebSocketコンストラクタ直後は接続中状態
- **B: 1 (OPEN)** - onopen内では接続確立済み
- **C: 3 (CLOSED)** - onclose内では完全に閉じられた状態

</details>

## 📝 演習2: WebSocketとHTTPの使い分け

以下のケースでWebSocketとHTTPのどちらが適切か判断してください：

1. **ユーザープロフィール情報の取得**
2. **チャットメッセージのリアルタイム配信**
3. **商品一覧の表示**
4. **株価のリアルタイム更新**
5. **ファイルのアップロード**

<details>
<summary>答えを見る</summary>

1. **HTTP** - 一度の取得で十分、リアルタイム性不要
2. **WebSocket** - 双方向リアルタイム通信が必要
3. **HTTP** - 静的データの取得、リアルタイム性不要
4. **WebSocket** - 高頻度リアルタイム更新が必要
5. **HTTP** - ファイル転送はHTTPが適している

</details>

## 📝 演習3: TypeScript実装

以下のTypeScript関数を完成させてください：

```typescript
interface ConnectionManager {
  connect(url: string): Promise<void>;
  disconnect(): void;
  send(message: string): boolean;
  isConnected(): boolean;
}

class WebSocketManager implements ConnectionManager {
  private ws: WebSocket | null = null;
  
  async connect(url: string): Promise<void> {
    // ここを実装してください
  }
  
  disconnect(): void {
    // ここを実装してください
  }
  
  send(message: string): boolean {
    // ここを実装してください
  }
  
  isConnected(): boolean {
    // ここを実装してください
  }
}
```

<details>
<summary>実装例を見る</summary>

```typescript
class WebSocketManager implements ConnectionManager {
  private ws: WebSocket | null = null;
  
  async connect(url: string): Promise<void> {
    return new Promise((resolve, reject) => {
      this.ws = new WebSocket(url);
      
      this.ws.onopen = () => resolve();
      this.ws.onerror = () => reject(new Error('Connection failed'));
    });
  }
  
  disconnect(): void {
    if (this.ws) {
      this.ws.close(1000, 'Normal closure');
      this.ws = null;
    }
  }
  
  send(message: string): boolean {
    if (this.ws?.readyState === WebSocket.OPEN) {
      this.ws.send(message);
      return true;
    }
    return false;
  }
  
  isConnected(): boolean {
    return this.ws?.readyState === WebSocket.OPEN;
  }
}
```

</details>

## 🏃‍♀️ 次のステップ

おめでとうございます！WebSocketの基本概念とTypeScriptでの実装方法を理解できました。

次の章では、WebSocketを取り巻くネットワーク技術について学習します：

- OSI参照モデルでのWebSocketの位置
- HTTP/1.1からHTTP/3までの対応状況
- プロキシ・ファイアウォール環境での動作

---

**チェックリスト**:
- [ ] WebSocketの基本概念を理解した
- [ ] HTTPとの違いを説明できる
- [ ] 実際のWebSocket接続を体験した
- [ ] TypeScriptでの型安全な実装を理解した
- [ ] 適用場面を判断できる

**進捗**: Chapter 1 完了 🎉